/*
// Author: Tom Gabrysiak
// Name:   Jigsaw Puzzle
// Date:   April 21st, 2012
*/
var EventEmitter = function() {};
EventEmitter.prototype.setMaxListeners = function(a) {
	if (!this._events) {
		this._events = {}
	}
	this._events.maxListeners = a
};
EventEmitter.prototype.emit = function(f) {
	if (f === "error") {
		if (!this._events || !this._events.error || (Array.isArray(this._events.error) && !this._events.error.length)) {
			if (arguments[1] instanceof Error) {
				throw arguments[1]
			} else {
				throw new Error("Uncaught, unspecified 'error' event.")
			}
			return false
		}
	}
	if (!this._events) {
		return false
	}
	var e = this._events[f];
	if (!e) {
		return false
	}
	if (typeof e == "function") {
		switch (arguments.length) {
		case 1:
			e.call(this);
			break;
		case 2:
			e.call(this, arguments[1]);
			break;
		case 3:
			e.call(this, arguments[1], arguments[2]);
			break;
		default:
			var b = Array.prototype.slice.call(arguments, 1);
			e.apply(this, b)
		}
		return true
	} else {
		if (Array.isArray(e)) {
			var b = Array.prototype.slice.call(arguments, 1);
			var d = e.slice();
			for (var c = 0, a = d.length; c < a; c++) {
				d[c].apply(this, b)
			}
			return true
		} else {
			return false
		}
	}
};
EventEmitter.prototype.publish = EventEmitter.prototype.emit;
EventEmitter.prototype.addListener = function(b, c) {
	if ("function" !== typeof c) {
		throw new Error("addListener only takes instances of Function")
	}
	if (!this._events) {
		this._events = {}
	}
	this.emit("newListener", b, c);
	if (!this._events[b]) {
		this._events[b] = c
	} else {
		if (Array.isArray(this._events[b])) {
			this._events[b].push(c);
			if (!this._events[b].warned) {
				var a;
				if (this._events.maxListeners !== undefined) {
					a = this._events.maxListeners
				} else {
					a = 10
				}
				if (a && a > 0 && this._events[b].length > a) {
					this._events[b].warned = true;
					console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[b].length);
					console.trace()
				}
			}
		} else {
			this._events[b] = [this._events[b], c]
		}
	}
	return this
};
EventEmitter.prototype.on = EventEmitter.prototype.subscribe = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function(b, d) {
	if ("function" !== typeof d) {
		throw new Error(".once only takes instances of Function")
	}
	var a = this;

	function c() {
		a.removeListener(b, c);
		d.apply(this, arguments)
	}
	c.listener = d;
	a.on(b, c);
	return this
};
EventEmitter.prototype.removeListener = function(c, f) {
	if ("function" !== typeof f) {
		throw new Error("removeListener only takes instances of Function")
	}
	if (!this._events || !this._events[c]) {
		return this
	}
	var e = this._events[c];
	if (Array.isArray(e)) {
		var a = -1;
		for (var b = 0, d = e.length; b < d; b++) {
			if (e[b] === f || (e[b].listener && e[b].listener === f)) {
				a = b;
				break
			}
		}
		if (a < 0) {
			return this
		}
		e.splice(a, 1);
		if (e.length == 0) {
			delete this._events[c]
		}
	} else {
		if (e === f || (e.listener && e.listener === f)) {
			delete this._events[c]
		}
	}
	return this
};
EventEmitter.prototype.unsubscribe = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(a) {
	if (arguments.length === 0) {
		this._events = {};
		return this
	}
	if (a && this._events && this._events[a]) {
		this._events[a] = null
	}
	return this
};
EventEmitter.prototype.listeners = function(a) {
	if (!this._events) {
		this._events = {}
	}
	if (!this._events[a]) {
		this._events[a] = []
	}
	if (!Array.isArray(this._events[a])) {
		this._events[a] = [this._events[a]]
	}
	return this._events[a]
};
EventEmitter.mixin = function(a) {
	for (var b in EventEmitter.prototype) {
		if (!a.prototype[b]) {
			a.prototype[b] = EventEmitter.prototype[b]
		}
	}
};