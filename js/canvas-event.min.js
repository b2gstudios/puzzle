/*
// Author: Tom Gabrysiak
// Name:   Jigsaw Puzzle
// Date:   April 21st, 2012
*/
(function() {
	var a = false;
	this.Class = function() {};
	Class.extend = function(h) {
		var g = this.prototype,
			e, d, f, c;
		a = true;
		e = new this();
		a = false;
		for (d in h) {
			e[d] = typeof h[d] == "function" && typeof g[d] == "function" ? (function(j, k) {
				return function() {
					f = this._super;
					this._super = g[j];
					c = k.apply(this, arguments);
					this._super = f;
					return c
				}
			})(d, h[d]) : h[d]
		}
		function b(j) {
			if (this instanceof arguments.callee) {
				if (!a && this.init) {
					this.init.apply(this, j && j.callee ? j : arguments)
				}
			} else {
				return new arguments.callee(arguments)
			}
		}
		b.prototype = e;
		b.constructor = b;
		b.extend = arguments.callee;
		return b
	}
})();
(function() {
	var I = this,
		m = I.document,
		g = Object.prototype.toString,
		t = "function",
		q = "string",
		j = "array",
		H = "object",
		O = "addEventListener",
		k = /webkit|msie/i.exec(I.navigator.userAgent),
		A = ("ontouchstart" in I) || I.DocumentTouch && document instanceof DocumentTouch,
		h = /^([#]?)([a-z][\w\-]*)$/,
		M = ["", "LEFT", "CENTER", "RIGHT"],
		p = [],
		w = null,
		u = null,
		b = false,
		L = "Cevent" + new Date().getTime(),
		n = 0,
		a = I.cache = {},
		d = (function() {
			return I.requestAnimationFrame || I.webkitRequestAnimationFrame || I.mozRequestAnimationFrame || I.oRequestAnimationFrame || I.msRequestAnimationFrame ||
			function(Q, P) {
				I.setTimeout(Q, 1000 / 60)
			}
		})(),
		B = function(Q, P) {
			return g.call(Q).slice(8, -1).toLowerCase() == P
		},
		J = function(R, S) {
			var Q, P = 0;
			if (B(R, j)) {
				for (;
				(Q = R[P++]) && S(Q, P) !== false;) {}
			}
		},
		z = function(Q) {
			var R = 0,
				P = 0;
			if (Q.offsetParent) {
				do {
					R += Q.offsetLeft;
					P += Q.offsetTop
				} while (Q = Q.offsetParent)
			}
			return {
				x: R,
				y: P
			}
		},
		N = function(S, Q, R) {
			var T = S[L],
				P;
			if (!T) {
				T = S[L] = ++n
			}
			P = a[T];
			if (!P) {
				P = a[T] = {}
			}
			if (Q && R !== undefined) {
				P[Q] = R
			}
			return Q ? P[Q] : P
		},
		D = function(Q, P) {
			if (!Q) {
				return
			}
			var R = Q[L];
			if (R && a[R]) {
				if (P) {
					delete a[R][P]
				} else {
					delete a[R]
				}
			}
		},
		o = function(T, R, S) {
			var P = N(T),
				Q;
			J(R.split(" "), function(U) {
				Q = P[U] = P[U] || [];
				Q.push(S)
			})
		},
		s = function(V, P, S, U) {
			var T, R = 0,
				Q = true;
			S.ctx.save();
			S.ctx.scale(S.__zoom, S.__zoom);
			for (;
			(T = P[R++]);) {
				if (T.call(V, S, U) === false) {
					Q = false
				}
			}
			S.ctx.restore();
			if (!Q) {
				U.preventDefault()
			}
			return Q
		},
		c = function(Q, R, T, P) {
			var S = N(P.cv, R);
			if (S && S.length) {
				p.push(Q, S)
			}
		},
		e = function(R, S) {
			var Q, P;
			R.clear();
			for (Q = 0, P = p.length; Q < P; Q += 2) {
				s(p[Q], p[Q + 1], R, S)
			}
			p = [];
			R.draw()
		},
		G, y = {
			log: function(P) {
				document.getElementById("clock").innerHTML = P
			}
		},
		l = function(T, R) {
			T.preventDefault();
			T = T.touches ? T.touches[0] : T;
			R.x = (((T && (T.pageX - R._pos.x) + 1) || I.event.offsetX + 1) - 1) / R.__zoom;
			R.y = (((T && (T.pageY - R._pos.y) + 1) || I.event.offsetY + 1) - 1) / R.__zoom;
			var Q, P = R._shapes,
				S = P.length;
			while ((Q = P[--S])) {
				if (Q.hitTest(R)) {
					return Q
				}
			}
		},
		v = function(P, Q) {
			i = 0;
			return function(S) {
				var R = S.touches ? S.touches[0] : S;
				S.preventDefault();
				P.lastX = P.x;
				P.lastY = P.y;
				P.x = (((S && (R.pageX - P._pos.x) + 1) || I.event.offsetX + 1) - 1) / P.__zoom;
				P.y = (((S && (R.pageY - P._pos.y) + 1) || I.event.offsetY + 1) - 1) / P.__zoom;
				if (!P._clicked) {}
				if (P._curHover) {
					c(P._curHover, "mousemove", S, P)
				}
				G = true;
				if (p.length) {
					e(P, S)
				}
			}
		},
		r = function(P) {
			return function(R) {
				var Q = P._curHover = l(R, P),
					S = M[R.which];
				P._clicked = true;
				w = P.cv;
				P[S] = true;
				if (Q) {
					c(Q, "mousedown", R, P);
					if (Q !== P.focused) {
						c(Q, "focus", R, P);
						if (P.focused) {
							c(P.focused, "blur", R, P)
						}
					}
					P.focused = Q
				} else {
					if (P.focused) {
						c(P.focused, "blur", R, P);
						P.focused = null
					}
				}
				if (p.length) {
					e(P, R)
				}
				P.LEFT = P.CENTER = P.RIGHT = undefined
			}
		},
		F = function(P) {
			return function(Q) {
				P._clicked = false;
				if (P._curHover) {
					c(P._curHover, "mouseup", Q, P);
					if (!G && A) {
						c(P._curHover, "click", Q, P)
					}
				}
				G = false;
				if (p.length) {
					e(P, Q)
				}
				P._curHover = null
			}
		},
		E = function(P) {
			return function(Q) {
				if (P._curHover) {
					c(P._curHover, "click", Q, P)
				}
				if (p.length) {
					e(P, Q)
				}
			}
		},
		x = function(P) {
			return function(Q) {
				if (P._curHover) {
					c(P._curHover, "dblclick", Q, P)
				}
				if (p.length) {
					e(P, Q)
				}
			}
		},
		f = (function() {
			var Q = {
				specialKeys: {
					27: "esc",
					9: "tab",
					32: "space",
					13: "return",
					8: "backspace",
					145: "scroll",
					20: "capslock",
					144: "numlock",
					19: "pause",
					45: "insert",
					36: "home",
					46: "del",
					35: "end",
					33: "pageup",
					34: "pagedown",
					37: "left",
					38: "up",
					39: "right",
					40: "down",
					109: "-",
					112: "f1",
					113: "f2",
					114: "f3",
					115: "f4",
					116: "f5",
					117: "f6",
					118: "f7",
					119: "f8",
					120: "f9",
					121: "f10",
					122: "f11",
					123: "f12",
					191: "/",
					96: "0",
					97: "1",
					98: "2",
					99: "3",
					100: "4",
					101: "5",
					102: "6",
					103: "7",
					104: "8",
					105: "9",
					106: "*",
					107: "+",
					110: ".",
					111: "/",
					187: "+",
					189: "-"
				},
				shiftNums: {
					"`": "~",
					"1": "!",
					"2": "@",
					"3": "#",
					"4": "$",
					"5": "%",
					"6": "^",
					"7": "&",
					"8": "*",
					"9": "(",
					"0": ")",
					"-": "_",
					"=": "+",
					";": ":",
					"'": '"',
					",": "<",
					".": ">",
					"../../../default.htm": "?",
					"\\": "|"
				},
			},
				P;
			return function(T, R) {
				var U = N(R.cv, T, {}),
					S = N(U);
				return function(aa) {
					if (w !== R.cv && !R.__globalkeyevents) {
						return
					}
					P = T == "keydown" ? aa.keyCode : P;
					var X = Q.specialKeys[P],
						Z = X || String.fromCharCode(P || aa.charCode).toLowerCase(),
						Y = "",
						V;
					if (aa.altKey) {
						Y += "alt+"
					}
					if (aa.ctrlKey || aa.metaKey) {
						Y += "ctrl+"
					}
					if (aa.shiftKey) {
						Y += "shift+"
					}
					V = (S[Y + Z] || S[Y + Q.shiftNums[Z]] || (Y === "shift+" && S[Q.shiftNums[Z]]) || S.any);
					if (V) {
						var W = s(R, V, R, aa);
						if (!R.play) {
							R.redraw()
						}
						return W
					}
				}
			}
		})(),
		C = function(Q, P) {
			Q = B(Q, q) ? m.getElementById(Q) : Q;
			if (Q.getContext) {
				return new C.fn.init(Q, P)
			} else {
				throw "your browser sucks"
			}
		};
	C.isTouchDevice = A;
	C.fn = C.prototype = {
		init: function(Q, P) {
			this.cv = Q;
			this.ctx = Q.getContext("2d");
			this.width = Q.width;
			this.height = Q.height;
			this.__zoom = 1;
			this.x = 0;
			this.y = 0;
			if (!this.cv[L]) {
				if (P) {
					this.buffer = document.getElementById(P).getContext("2d");
					N(Q, "buffer", this.buffer)
				}
				this._shapes = N(Q, "shapes", []);
				this._last = null;
				this.calcCanvasPosition();
				if (A) {
					Q[O]("touchmove", v(this), false);
					Q[O]("touchend", F(this), false);
					Q[O]("touchstart", r(this), false)
				} else {
					Q[O]("mousemove", v(this), false);
					Q[O]("dblclick", x(this), false);
					Q[O]("click", E(this), false);
					Q[O]("mouseup", F(this), false);
					Q[O]("mousedown", r(this), false);
					m[O]("keydown", f("keydown", this), false);
					m[O]("keyup", f("keyup", this), false);
					if (!k) {
						m[O]("keypress", f("keypress", this), false)
					}
					if ("onselectstart" in Q) {
						Q.onselectstart = function() {
							return false
						};
						Q.onmousedown = function() {
							return false
						}
					}
				}
			} else {
				this._shapes = N(Q, "shapes");
				this.buffer = N(Q, "buffer");
				this._last = P
			}
		},
		calcCanvasPosition: function() {
			this._pos = z(this.cv);
			return this
		},
		get: function(P) {
			P = P < 0 ? this._shapes.length + P : P;
			return this._shapes[P] || this._shapes
		},
		getAll: function(P) {
			var S = [],
				R = h.exec(P),
				T, Q;
			if (P === "*") {
				S = this._shapes.slice(0)
			} else {
				if (R) {
					T = R[1];
					Q = R[2];
					J(this._shapes, function(U) {
						if (U[T] === Q) {
							S.push(U)
						}
					})
				}
			}
			return S
		},
		remove: function(P) {
			var Q = this._shapes.indexOf(P);
			if (Q >= 0) {
				this._shapes.splice(Q, 1)
			}
			return this.redraw()
		},
		addId: function(R) {
			var Q = h.exec(R),
				P = this._last;
			if (Q && !Q[1] && P) {
				if (!P.length) {
					P["#"] = R
				} else {
					J(P, function(S) {
						S["#"] = R
					})
				}
			}
			return this
		},
		removeId: function() {
			var P = this._last;
			if (P && !P.length) {
				P["#"] = ""
			} else {
				J(P, function(Q) {
					Q["#"] = ""
				})
			}
			return this
		},
		find: function(P) {
			var Q = this.getAll(P);
			return C(this.cv, Q.length == 1 ? Q[0] : Q)
		},
		attr: function(Q, R) {
			var P = this._last;
			if (P && P.attr) {
				P.attr(Q, R)
			} else {
				J(P, function(S) {
					S.attr(Q, R)
				})
			}
			return this
		},
		rotate: function(P) {
			return this.attr({
				rotation: P
			})
		},
		translate: function(P, Q) {
			return this.attr({
				tx: P,
				ty: Q
			})
		},
		scale: function(P, Q) {
			return this.attr({
				scaleX: P,
				scaleY: Q
			})
		},
		skewX: function(P) {
			return this.attr({
				skewX: P
			})
		},
		skewY: function(P) {
			return this.attr({
				skewY: P
			})
		},
		zoomTo: function(P) {
			if (B(P, "number")) {
				this.__zoom = P
			}
			return this
		},
		zoomIn: function() {
			return this.zoomTo(this.__zoom + 0.1)
		},
		zoomOut: function() {
			return this.zoomTo(this.__zoom - 0.1)
		},
		setGlobalKeyEvents: function(P) {
			this.__globalkeyevents = P;
			return this
		},
		bind: function(Q, S, T) {
			var P = T || this._last,
				R;
			if (B(Q, q) && B(S, H)) {
				for (R in S) {
					this[R](Q, S[R])
				}
			} else {
				if (B(Q, H)) {
					for (R in Q) {
						this[R](Q[R])
					}
				} else {
					if (P && !P.length) {
						o(P, Q, S)
					} else {
						J(P, function(U) {
							o(U, Q, S)
						})
					}
				}
			}
			return this
		},
		beforeDraw: function(P) {
			if (B(P, t)) {
				this.__beforeDraw = P
			}
			return this
		},
		afterDraw: function(P) {
			if (B(P, t)) {
				this.__afterDraw = P
			}
			return this
		},
		clear: function(Q, S, R, P) {
			Q = Q || 0;
			S = S || 0;
			R = R || this.cv.width;
			P = P || this.cv.height;
			this.ctx.clearRect(Q, S, R, P);
			return this
		},
		draw: function() {
			var Q, R = 0,
				P = this._shapes;
			this.ctx.save();
			C.__zoom = this.__zoom;
			this.__beforeDraw && this.__beforeDraw.call(this);
			if (b) {
				this._curHover.draw(this.ctx)
			} else {
				for (;
				(Q = P[R++]);) {
					Q.draw(this.ctx)
				}
			}
			this.__afterDraw && this.__afterDraw.call(this);
			C.__zoom = 1;
			this.ctx.restore();
			return this
		},
		redraw: function() {
			return this.clear().draw()
		},
		loop: function(R) {
			var P = this,
				S = N(this.cv),
				Q;
			if (!B(R, t) && !B(S.loop, t)) {
				throw new Error("Function required")
			}
			if (B(R, t)) {
				S.loop = R
			}
			R = S.loop;
			Q = this.play = ++n;
			(function() {
				if (Q !== P.play) {
					return
				}
				d(arguments.callee);
				P.redraw();
				if (R) {
					P.ctx.save();
					R.call(P, P);
					P.ctx.restore()
				}
				P.frameCount += 1
			}());
			return this
		},
		frameCount: 0,
		stop: function() {
			delete this.play;
			return this
		}
	};
	C.fn.init.prototype = C.prototype;

	function K(P, R) {
		var Q = h.exec(P);
		return function(S, T) {
			if (Q && this[Q[1]] === Q[2] || P === "*") {
				R.call(this, S, T)
			}
		}
	}
	J("mousemove mouseover mouseout mousedown mouseup click dblclick focus blur".split(" "), function(P) {
		C.fn[P] = function(R, Q) {
			var S;
			if (B(Q, t)) {
				R = K(R, Q);
				S = this.cv
			}
			return this.bind(P, R, S)
		}
	});
	J("keydown keypress keyup".split(" "), function(P) {
		C.fn[P] = function(Q, R) {
			if (!R && B(Q, t)) {
				R = Q;
				Q = "any"
			}
			Q = (Q + "").toLowerCase();
			return this.bind(Q, R, N(this.cv, P))
		}
	});
	if (k) {
		C.fn.keypress = C.fn.keydown
	}
	C.fn.drag = function(T, R) {
		var Q, S, U, W, V = [],
			X = "Cevent-drag" + L,
			P = this._last;
		if (R) {
			Q = R.start;
			S = R.move;
			U = R.end
		}
		this.bind(T, {
			mousedown: function(aa, Z) {
				if (aa.LEFT || A) {
					var Y = aa.ctx;
					aa.clear();
					aa.ctx = aa.buffer;
					this.hide = true;
					aa.draw();
					this.hide = false;
					aa.ctx = Y;
					u = this;
					aa.cv.style.cursor = "move"
				}
			},
			mousemove: function(Z, Y) {
				if (this === u) {
					this.rmove(Z.x - Z.lastX, Z.y - Z.lastY);
					if (!b) {
						b = true;
						if (Q) {
							Q.call(this, Z, Y)
						}
					}
					if (S) {
						S.call(this, Z, Y)
					}
				}
			},
			mouseup: function(aa, Z) {
				if (this === u) {
					u = b = null;
					var Y = aa.ctx;
					aa.ctx = aa.buffer;
					aa.clear();
					aa.ctx = Y;
					aa.cv.style.cursor = "default";
					if (U) {
						U.call(this, aa, Z)
					}
				}
			}
		});
		return this
	};
	C.registre = C.register = function(R, P) {
		R = R.toLowerCase();
		var Q = R.charAt(0).toUpperCase() + R.substring(1);
		this[Q] = P;
		this.prototype[R] = function() {
			var S = P.apply(this, arguments);
			S[""] = R;
			this._shapes.push(S);
			this._last = S;
			return this
		}
	};
	m[O]("mousedown", function(P) {
		if (!P.target[L] && P.target.nodeName !== "CANVAS") {
			w = null
		}
	}, false);
	I.Cevent = C
}());
(function(m, o) {
	var e = Math,
		t = e.PI,
		f = 2 * t,
		j = t / 180,
		z = e.sqrt,
		k = e.pow,
		c = e.cos,
		a = e.sin,
		y = e.round,
		r = e.abs,
		q = e.acos,
		d = e.atan2,
		l, p = Object.prototype.hasOwnProperty,
		u = Array.prototype.slice,
		w = {
			tx: 0,
			ty: 0,
			scaleX: 1,
			scaleY: 1,
			skewX: 0,
			skewY: 0,
			fill: "#000",
			stroke: "",
			lineWidth: 1,
			lineJoin: "miter",
			lineCap: "butt",
			alpha: 1,
			rotation: 0,
			composite: "source-over",
			shadowColor: "rgba(0, 0, 0, 0.0)",
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			shadowBlur: 0,
			fontStyle: "normal",
			fontWeight: "normal",
			fontSize: 10,
			fontFamily: "Arial"
		},
		h = document.createElement("canvas"),
		b = h.getContext("2d"),
		g = function(B, A) {
			return z(k(B.x - A.x, 2) + k(B.y - A.y, 2))
		},
		s = function(B, G, A, F, H) {
			var E = A - B,
				D = F - G,
				C = {},
				I;
			if (E === 0 && D === 0) {
				return
			}
			I = ((H.x - B) * E + (H.y - G) * D) / (E * E + D * D);
			if (I < 0) {
				C = {
					x: B,
					y: G
				}
			} else {
				if (I > 1) {
					C = {
						x: A,
						y: A
					}
				} else {
					C = {
						x: B + I * E,
						y: G + I * D
					}
				}
			}
			return g(C, H)
		},
		v = function(A, C, B) {
			B = j * B;
			return {
				x: A * c(B) - C * a(B),
				y: A * a(B) + C * c(B)
			}
		},
		x = function(C, B) {
			var A;
			for (A in B) {
				if (p.call(B, A)) {
					C[A] = B[A]
				}
			}
		},
		n = Class.extend({
			init: function(A, B) {
				this.x = A || 0;
				this.y = B || 0;
				x(this, w)
			},
			position: function() {
				var A = v(this.x * this.scaleX, this.y * this.scaleY, this.rotation);
				return {
					x: A.x + this.tx,
					y: A.y + this.ty
				}
			},
			rmove: function(A, B) {
				this.tx += A;
				this.ty += B
			},
			attr: function(B, C) {
				var A;
				if (typeof B == "string") {
					this[B] = C
				} else {
					for (A in B) {
						this[A] = B[A]
					}
				}
				return this
			},
			applyStyle: function(B) {
				var A = this.shadowBlur,
					D = this.shadowOffsetX,
					C = this.shadowOffsetY;
				B.fillStyle = this.fill;
				B.globalAlpha = this.alpha;
				B.globalCompositeOperation = this.composite;
				if (this.stroke) {
					B.strokeStyle = this.stroke;
					B.lineWidth = this.lineWidth
				}
				if (D || C || A) {
					B.shadowColor = this.shadowColor;
					B.shadowOffsetX = D;
					B.shadowOffsetY = C;
					B.shadowBlur = A
				}
			},
			setTransform: function(M) {
				var L = m.__zoom,
					J = this.scaleX * L,
					I = this.scaleY * L,
					H = this.skewX * L,
					G = this.skewY * L,
					C = this.rotation * j,
					O = a(C),
					F = c(C),
					N = this.tx * L,
					K = this.ty * L,
					E = F * J - O * G,
					B = F * H - O * I,
					D = O * J + F * G,
					A = O * H + F * I;
				M.setTransform(E, D, B, A, N, K)
			},
			draw: function(A) {
				throw new Error("El método draw no se ha implementado")
			},
			fill_or_stroke: function(A) {
				if (this.fill) {
					A.fill()
				}
				if (this.stroke) {
					A.stroke()
				}
			},
			hitTest: function(A) {
				this.draw(b);
				return b.isPointInPath(A.x, A.y)
			}
		});
	x(m, {
		Shape: n,
		__zoom: 1
	})
})(Cevent, this);